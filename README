# Theory Exploration Benchmarks #

This repository contains scripts to create large(ish) benchmarks for theory
exploration systems. It's based on the Tons of Inductive Problems (TIP) problem
set, but whilst TIP focuses on depth (proving a given theorem from minimal
premises), we focus on breadth (discovering theorems from many premises).

We use Racket, since it's well suited to manipulating the s-expressions defined
by TIP.

## How it Works ##

Each TIP benchmark defines datatypes, functions and a single (negated) theorem
statement. These scripts combine the datatypes and functions from all of these
benchmarks together, and strip out all of the theorem statements.

The result is a large theory, suitable for exploration by tools like QuickSpec
and IsaCoSy, and suitable for passing into the standard tip tools (e.g. for
translation into various other languages).

Combining all of these theories into one causes a few problems. In particular:

 - Multiple files may declare functions or datatypes of the same name. To allow
   for this, we prefix all defined names by the path from which they're taken.
   Hence a function called "add" in the file "arithmetic/plus_commutes.smt2"
   will become "arithmetic/plus_commutes.smt2add".
 - We may get multiple definitions of the same (alpha-equivalent) values, e.g.
   if multiple benchmarks define the same natural number type and functions. We
   find these by normalising each definition and looking for duplicates. If any
   are found, we keep the first and remove the others; we also switch out the
   names for whichever of the duplicates occurs first lexicographically, and
   update all references elsewhere accordingly. We iterate this process until
   no more duplicates are found, which gives us O(n^3) worst-case time.
 - Many definitions have names which aren't suitable for targets like Haskell;
   especially when prefixed by their path. The `tip` program will rename such
   definitions when translating, but this is difficult to reverse. To prevent
   this, we hex-encode all names, and prefix with either `global` or `Global`
   (following Haskell's upper/lowercase distinction between types/constructors
   and functions/destructors).
 - To ease automation, we add an extra function for each constructor (prefixed
   with "constructor-") and for each destructor (prefixed with "destructor-").

## Dependencies ##

All dependencies can be satisfied automatically by the Nix package manager,
using the included `default.nix` file. This provides the following attributes:

 - `tools`, which provides our TIP-manipulation scripts
 - `tip-benchmarks`, which is a specific revision of the TIP benchmarks
 - `tip-benchmark-smtlib`, which is the result of using the `tools` scripts to
   combine all of the `tip-benchmarks` together

These definitions are parameterised by the package repository and set of Haskell
packages to use, which allows easy overriding and aids reproducibility.

If you don't want to use Nix, you'll need `racket` in your `PATH`, with the
`shell-pipeline` package available.

If you want to generate Haskell code you'll need the `tip` command, from the
`tip-lib` Haskell package.

You can invoke the test suite using `raco` or `drracket`; the tests also need
the `cabal` command, and a Haskell environment with the `QuickSpec`,
`QuickCheck`, `tip-lib` and `testing-feat` packages available.

The preferred way to use these tools is to `import` them into your own Nix
projects. Alternatively, you can enter a shell to run commands manually
(although this sacrifices the reproducibility offered by Nix):

    nix-shell -p '(import ./. {}).tools'

This will enter a shell with the `tools` available in `PATH`.

## Usage ##

To generate a benchmark from some TIP benchmarks, pipe their filenames into
`mk_final_defs.rkt`, one per line. This will send the resulting benchmark
s-expressions to stdout.

To generate a Haskell package from a benchmark, pipe it into
`full_haskell_package.rkt`. Make sure to set the `OUT_DIR` environment variable
to a path in which the package will be created.

To test, use Racket's `raco` command:

    raco test defs.rkt

You'll need to set the `BENCHMARKS` environment variable to a directory of TIP
benchmarks, and you can force contract checking (a dynamic equivalent to type
checking) setting the environment variable `PLT_TR_CONTRACTS` to `1`.

Tests can also be run in other ways, e.g. using Dr Racket.

## Other Uses ##

Besides benchmarking theory exploration systems based on their resource usage,
we can also use the theorem statements from TIP problems as a ground truth for
measuring the effectiveness of each exploration. For example, if we only
compared systems based on the number of theorems they discover, it would be
trivial to score highly by generating "uninteresting" theorems such as:

    (=       Z         Z  )
    (=    (S Z)     (S Z) )
    (= (S (S Z)) (S (S Z)))
    ...

Such theorems are too dull to bother writing into a benchmark. In comparison,
more interesting properties like commutativity *are* found in benchmarks, such
as this from `benchmarks/tip2015/int_add_comm.smt2` in the TIP benchmarks repo:

    (= (plus x y) (plus y x))

Hence a theorem can be deemed interesting if it appears in a benchmark. Whilst
far from comprehensive, the set of benchmarks is easy to extend as new cases
arise.
